## 线段树

### 基本操作

`build`

- 将一段区间初始化成线段树

`query`

- 查询某一段区间的信息

`modify`

- 修改某一个点或者某一个区间，包括**单点修改**和**区间修改**
  
  > 区间修改通常需要用到懒标记

`pushup`

- 由子节点的信息更新父节点信息

`pushdown`(懒/延迟标记)

- 将父节点的信息下传到子节点

### 表示方法

- 通常用一维数组来存树中的所有节点(堆的方式)
  
  - 对于编号为 `x` 的节点，有
    
    ```bash
    # 父节点 
    x >> 1
    # 左儿子
    x << 1
    # 右儿子
    x << 1 | 1
    ```

- 通常需要用 $4 \times N$ 的数组来存储所有的节点($N$ 为区间的长度)
  
  > 倒数第二层最多 $N$ 个(实际上取 $N$ 时，则倒数第二层变为倒数第一层)节点(每个节点存储长度为 $1$ 的区间)，因此最多 $N - 1 + N + 2 \times N = 4 \times N - 1$  个节点(不可能取等号)

### 常见例题

#### 单点修改，区间查询

> 解决此类题目时不需要 `pushdown` 操作

##### 例题1[^1]

> 给定一个正整数序列 $a_1, a_2, \cdots, a_n$，每一个数都在 $0 \sim  p - 1$ 之间，可以对这列数进行如下两种操作：
> 
> 1. 添加操作：向序列后添加一个数，序列长度变为 $n + 1$
> 
> 2. 询问操作：询问这个序列中最后 $L$ 个数中最大的数是多少
> 
> 程序运行的最开始，整数序列为空，一共要对整数序列进行 $m$ 次操作

**分析：**

假设完成添加操作后数组 $A$ 的总长度为 $l$，$n$ 为当前已经添加的正整数个数，且初始化时数组中的所有元素为 $0$，则上述两个操作可以转化如下：

1. $A[n + 1] = a_{n + 1}$

2. $\sum_{i = n - L + 1}^n A[i]$

即典型的单点修改，区间查询问题，可以用不带懒标记的线段树解决

##### 例题2[^2]

> 给定一个长度为 $N$ 的数列 $A$，以及 $M$ 条指令，每条指令可能是以下两种之一：
> 
> 1. `C l r d`，表示把 $A[l], A[l + 1], \cdots, A[r]$ 都加上 $d$
> 
> 2. `Q l r`，表示询问 $A[l], A[l + 1],\cdots, A[r]$ 的最大公约数

**分析：**

乍一看，此题涉及到区间修改和区间查询操作，不能采取之前的”单点修改，区间查询“的思路，但仔细一想，其实操作 1 利用差分的思想转换为 **单点修改**，而根据辗转相除法，我们有

$$
gcd(a_1, \cdots, a_n) = gcd(a_1, a_2 - a_1, \cdots, a_n - a_{n - 1})
$$

因此，我们可以构造数列 $A$ ($A[0] = 0$)的差分数列 $B$，且使得

$$
B[i] = A[i] -A[i - 1]
$$

则上述两个操作可以转换为

1. $B[l] + d$ 同时 $B[r + 1] - d$

2. $gcd(\sum_{i = 1}^l B[i], B[l + 1], \cdots, B[r])$

也变成了 **单点修改，区间查询** 的问题，同理可以用不带懒标记的线段树进行解决

#### 区间修改，区间从查询

##### 例题1[^3]

> 给定一个长度为 $N$ 的数列 $A$，以及 $M$ 条指令，每条指令可能是以下两种之一
> 
> 1. `C l r d`，表示把 $A[l], A[l + 1], \cdots, A[r]$ 都加上 $d$
> 
> 2. `Q l r`，表示询问数列中 $l \sim r$ 个数的和

**分析：**

非常基本的区间修改，区间查询问题，对于线段树的节点，我们定义如下

```cpp
struct Node {
    // 节点包括的左、右区间
    int l, r;
    // 区间和
    long long sum;
    // 懒标记，用来对 **子节点** 进行延迟标记 
    long long add;
};
```

在带有懒标记的线段树中，`query` 和 `modify` 子节点前均需要进行 `pushdown` 操作

```cpp
long long query(int u, int l, int r) {
    // 如果线段树区间在 [l, r] 之内，则直接返回节点的 sum
    // ...

    // query 子节点需要首先进行 pushdown
    pushdown(u);
    // query 子节点
    // ...

void modify(int u, int l, int r, int d) {
    // 如果线段树区间在 [l, r] 之内，则直接修改 sum 和懒标记 add
    // ...

    // modify 子节点之前需要进行 pushdown
    pushdown(u);
    // modify 子节点
    // ...
    pushup(u);
}
```

##### 例题2[^4]

> 一共有 $n$ 张地图，每张地图用 $x_1, y_1, x_2, y_2$ 表示，其中 $(x_1, y_1)$ 表示地图的左上角位置，$(x_2, y_2)$ 表示地图的右下角位置，求所有地图的总面积

**分析：**

## Refs

[^1]: [1275. 最大数](https://www.acwing.com/problem/content/1277/)
[246. 区间最大公约数](https://www.acwing.com/problem/content/247/)
[243. 一个简单的整数问题2](https://www.acwing.com/problem/content/244/)

[^4]: [247. 亚特兰蒂斯](https://www.acwing.com/problem/content/description/249/)