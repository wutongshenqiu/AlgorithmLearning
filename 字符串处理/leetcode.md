### 匹配子序列的单词数

> 给定字符串 `s` 和字符串数组 `words`，返回 `words` 中的每个单词 `word` 是 `s` 的子序列的单词个数

- 暴力思路
  
  - 首先想到的思路是进行暴力匹配，显然判断一个字符串是否是另一个字符串的子序列的时间复杂度为 $O(n + m)$，其中 $n, m$ 分别为两个字符串的长度

- 二分搜索
  
  > 仅适用于 `words` 的长度远小于 `s` 的情况
  
  - 回顾判断 `word` 是否是 `s` 子序列暴力求解的过程，我们首先用两个指针 $i, j$ 依次指向 `word` 和 `s` 的起始位置，表示当前要匹配的字符，且进行如下判断
    
    $$
    \begin{cases}
j \mathrel{+}= 1, & \quad word[i] \ne s[j] \\
i \mathrel{+}= 1, j \mathrel{+}= 1 & \quad word[i] = s[j] 
\end{cases}
    $$
  
  - 在上述判断过程中，即使 `words` 的长度远小于 `s`，我们仍然可能需要遍历整个 `words` 字符串，那么有没有可能进行相应的优化呢
  
  - 优化的核心思想是 **快速找出 `word[i]` 在 `s` 中的位置**，在暴力做法中，我们是从前往后依次遍历字符串，但实际上我们可以对 `s` 进行预处理，按照顺序存储 `s` 的每个字符在 `s` 中出现的位置，同时我们记录 `words` 的前 `i - 1` 个字符已经在 `s` 中匹配的位置 `pos`， 那么我们就可以利用二分搜索快速找出 `words[i]` 在 `s` 中大于 `pos` 出现的位置

- 多指针
  
  - 对于每一个 `s` 中的字符，用多个指针分别指向 `words` 的每一个 `word` 并进行匹配


