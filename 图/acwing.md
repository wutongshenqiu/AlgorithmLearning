### 拓扑排序

#### BFS

- 记录每个点的入度
- 维护一个队列，队列的初始值为第一个入度为 $0$ 的点
- 重复进行如下操作，直到队列为空
  1. `pop` 队尾元素 $v$
  2. 依次遍历 $v$ 的所有边，将边指向顶点的入度减 $1$，如果该顶点未被访问且入度 $\le 0$，则将其加入队列中，并标记为已访问
- 如果所有的点都已经访问，则存在拓扑序列，否则不存在

### dijkstra

#### 朴素

- 起点到其他所有点的距离初始化为正无穷，到自己的距离为 $0$

- 重复执行下列操作 $n$ 次
  
  1. 在距离数组 $dist$ 中找到最近且未访问过的点 $u$
  
  2. 如果没有找到，则跳出循环；否则置该点已访问
  
  3. 遍历该点的所有出边，对于出边对应的点 $v$，如果 $v$ 没有被访问，则更新 $dist[v]$ 
     
     $$
     dist[v] = min(dist[v], dist[u] + weight_{u \rightarrow v})
     $$

- 距离数组 $dist$ 即为起点到其他所有点的最短距离

#### 堆优化

- 起点到其他所有点的距离初始化为正无穷(包括自己)

- 元素需要维护**到起点的距离**以及**顶点号**两个信息，并根据到起点的距离构造小根堆

- 堆中初始元素包含**到起点的距离 $0$**以及**起点自身**

- 重复下列操作直到堆为空(这里不是 $n$ 次，因为可能访问重复顶点)
  
  1. $pop$ 小根堆并获取距离 $dis$ 和顶点 $p$
  2. 如果顶点 $p$ 已经访问，则`continue`，否则执行下述步骤
  3. 置顶点 $p$ 已访问，并更新 $dist[p] = dis$
  4. 遍历 $p$ 的所有出边，对于出边对应的点 $v$，如果 $v$ 没有被访问并且到起点的距离大于 $dis + weight_{u \rightarrow v}$，则将 $dis + weight_{u \rightarrow v}$ 和 $v$ 加入小根堆

- 距离数组 $dist$ 即为起点到其他所有点的最短距离

### bellman-ford

- 起点到其他所有点的距离初始化为正无穷，到自己的距离为 $0$
- 重复遍历所有的边 $u \stackrel{w}{\longrightarrow} v$ ，$n$ 次并对每一条边执行如下操作
  - $dist[v] = min(dist[v], dist[u] + w)$

### spfa

- 起点到其他所有点的距离初始化为正无穷，到自己的距离为 $0$

- 维护一个队列，队列的初始元素为起点

- 重复如下操作，直到队列为空
  
  1. $pop$ 队尾元素 $v$
  
  2. 依次遍历 $v$ 的所有边 $v \stackrel{w}{\longrightarrow} v$，如果满足如下条件，则更新 $dist[v]$ 并且将 $v$ 加入队首
     
     $$
     dist[v] > dist[u] + w
     $$

- 记录数组 $dist$ 即为起点到其他所有点的最短距离

- **==spfa判断负环只需要看某一个点是否被 $pop$ $n$ 次以上==**

### floyd

- 动态规划，考虑从 $i$ 到 $j$ 并且经过前 $k$ 个点的最短距离
- 这个感觉没啥用，时间复杂度太高了

### prim

- 最小生成树算法一般用在无向图中，因此我们可以任意节点作为根节点，这里我们设定根节点为 $st$

- 根节点到其他所有点的距离初始化为正无穷，到自己的距离为零

- 用 $cnt$ 维护当前经过的节点数，$cost$ 维护当前的开销

- 执行下列操作 $n$ 次
  
  1. 找到距离数组 $dist$ 最近且未被访问过的点 $u$
  
  2. 如果没找到，跳出循环，否则 $cnt = cnt + 1$，$cost = cost + dist[u]$
  
  3. 对于点 $u$ 的所有出边 $u \stackrel{w}{\longrightarrow} v$，如果 $v$ 没有被访问，更新 $dist[u]$
     
     $$
     dist[u] = min(dist[u], w)
     $$

- 如果 $cnt < n$，则不存在最小生成树，否则 $cost$ 即为最小生成树所有边的权值之和

### kruskal

- 对所有的边按照降序排序

- 用 $cnt$ 维护当前选择的边数，$cost$ 维护当前的开销，$fa$ 维护并查集的父亲数组

- 遍历所有的边 $u \stackrel{w}{\longrightarrow} v$
  
  1. 找到 $u$ 和 $v$ 的祖先 $pu$，$pv$
     
     $$
     pu = find(u) \\
pv = find(v)
     $$
  
  2. 如果 $pu = pv$，则 `continue`，否则置 $fa[pu] = pv$
  
  3. $cnt = cnt + 1$，$cost = cost + w$
  
  4. 如果 $cnt = n - 1$，则 `break`

- 如果 $cnt < n - 1$ **==注意和prim的区别==**，则不存在最小生成树，否则 $cost$ 即为最小生成树所有边的权值之和